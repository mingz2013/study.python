__author__ = 'tuyou'
def ping():
    print "PING"
    pong()

def pong():
    print "PONG"
    ping()

ping()
'''
3.1.1堆栈
我仔细考虑了，自己对C语言堆栈的细节究竟了解多少，最终还是决定完全不去讲它。似乎，其他人对其所尝试的描述，以及图表，只有本身已经理解了的人才能看得懂。我将试着给出一个最简单的说明，而对其有更多兴趣的读者可以从网上查找更多信息。
每当一个子例程被调用，都有一个“栈帧”被建立，这是用来保存变量，以及其他子例程局部信息的区域。于是，当你调用ping()，则有一个栈帧被建立，来保存这次调用相关的信息。简言之，这个帧记载着ping被调用了。当再调用pong()，则又建立了一个栈帧，记载着pong也被调用了。这些栈帧是串联在一起的，每个子例程调用都是其中的一环。就这样，堆栈中显示：ping被调用所以pong接下来被调用。显然，当pong()再调用ping()，则使堆栈再扩展。下面是个直观的表示：

现在假设，这个页面的宽度就表示系统为堆栈所分配的全部内存空间，当其顶到页面的边缘的时候，将会发生溢出，系统内存耗尽，即术语“堆栈溢出”
'''